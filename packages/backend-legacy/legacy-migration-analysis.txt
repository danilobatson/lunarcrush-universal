Legacy directory structure:
./node_modules/@cloudflare/unenv-preset/dist/runtime/node/tls.d.ts
./node_modules/@cloudflare/unenv-preset/dist/runtime/node/crypto.d.ts
./node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.d.ts
./node_modules/@cloudflare/unenv-preset/dist/runtime/node/async_hooks.d.ts
./node_modules/@cloudflare/unenv-preset/dist/runtime/node/module.d.ts
./node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.d.ts
./node_modules/@cloudflare/unenv-preset/dist/runtime/node/util.d.ts
./node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.d.ts
./node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/package.json
./node_modules/@cloudflare/unenv-preset/dist/runtime/npm/debug.d.ts
./node_modules/@cloudflare/unenv-preset/dist/index.d.ts
./node_modules/@cloudflare/unenv-preset/package.json
./node_modules/unenv/dist/index.d.ts
./node_modules/unenv/runtime/_internal/types.d.ts
./node_modules/unenv/runtime/_internal/utils.d.ts
./node_modules/unenv/runtime/mock/empty.d.ts
./node_modules/unenv/runtime/mock/proxy.d.ts
./node_modules/unenv/runtime/mock/noop.d.ts
./node_modules/unenv/runtime/fetch/call.d.ts
./node_modules/unenv/runtime/fetch/index.d.ts

=== LEGACY PACKAGE.JSON ===
{
  "name": "@lunarcrush/universal-backend",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "wrangler dev --local",
    "deploy": "npx wrangler@latest deploy",
    "db:migrate": "wrangler d1 execute lunarcrush-universal-db --local --file=./src/migrations/0001_initial_schema.sql",
    "db:query": "wrangler d1 execute lunarcrush-universal-db --local --command",
    "db:remote": "wrangler d1 execute lunarcrush-universal-db --remote --command",
    "build": "echo 'Build complete'",
    "test": "echo 'Tests not implemented yet'"
  },
  "dependencies": {
    "@apollo/server": "^5.0.0",
    "@cloudflare/unenv-preset": "^2.4.0",
    "@google/generative-ai": "^0.24.1",
    "@lunarcrush/shared-types": "workspace:*",
    "@modelcontextprotocol/sdk": "^1.16.0",
    "graphql": "^16.11.0",
    "graphql-tag": "^2.12.6",
    "hono": "^4.6.12",
    "node-fetch": "^3.3.2",
    "unenv": "^1.10.0"
  },
  "devDependencies": {
    "@cloudflare/workers-types": "^4.20250722.0",
    "@hono/node-server": "^1.13.7",
    "@types/node": "^24.1.0",
    "typescript": "^5.8.3",
    "wrangler": "^4.25.1"
  },
  "packageManager": "yarn@4.0.0"
}

Legacy src/ structure:
total 40
drwxr-xr-x  10 batson  staff   320 Jul 24 22:53 .
drwxr-xr-x@ 18 batson  staff   576 Jul 28 09:57 ..
-rw-r--r--@  1 batson  staff  6148 Jul 25 00:16 .DS_Store
-rw-r--r--   1 batson  staff   849 Jul 24 22:53 example-imports.ts
drwxr-xr-x@  3 batson  staff    96 Jul 24 22:53 generated
drwxr-xr-x   8 batson  staff   256 Jul 24 22:53 graphql
-rw-r--r--@  1 batson  staff  5629 Jul 25 23:00 index.ts
drwxr-xr-x   3 batson  staff    96 Jul 24 22:53 migrations
drwxr-xr-x   5 batson  staff   160 Jul 24 22:53 services
drwxr-xr-x@  2 batson  staff    64 Jul 24 22:53 types.backup

=== LEGACY MAIN IMPLEMENTATION (index.ts) ===
File size:      241 lines
import { Hono } from 'hono';
import { cors } from 'hono/cors';
import { handleGraphQLRequest, createGraphQLServer } from './graphql/server';

// Type definitions for Cloudflare Workers environment
interface Env {
	LUNARCRUSH_API_KEY?: string;
	[key: string]: any;
}

interface HonoContext {
	env: Env;
	req: any;
	json: (obj: any) => Response;
}

const app = new Hono<{ Bindings: Env }>();

// Add CORS middleware
app.use(
	'*',
	cors({
		origin: [
			'https://studio.apollographql.com',
			'https://lunarcrush-universal-backend.cryptoguard-api.workers.dev',
		],
		credentials: true,
		allowMethods: ['GET', 'POST', 'OPTIONS'],
		allowHeaders: ['Content-Type', 'Authorization', 'Apollo-Require-Preflight'],
	})
);

// Environment interface
interface Environment {
	LUNARCRUSH_API_KEY: {
		get(): Promise<string>;
	};
	CRYPTO_CACHE?: any;
	DB?: any;
}

// ===== API KEY TEST ENDPOINT =====
app.get('/test-api-key', async (c) => {
	try {
		console.log('Testing API key binding access...');

		// Test if the binding exists
		if (!c.env?.LUNARCRUSH_API_KEY) {
			return c.json({
				success: false,
				error: 'LUNARCRUSH_API_KEY binding not found',
				available_bindings: Object.keys(c.env || {}),
				timestamp: new Date().toISOString(),
			});
		}

		// Get the API key using the correct binding method
		const apiKey = await c.env.LUNARCRUSH_API_KEY.get();

		if (!apiKey) {
			return c.json({
				success: false,
				error: 'API key is null or empty',
				binding_exists: !!c.env.LUNARCRUSH_API_KEY,
				timestamp: new Date().toISOString(),
			});
		}

		// Test the API key with a simple LunarCrush request
		console.log(`Testing API key: ${apiKey.substring(0, 10)}...`);

		const testResponse = await fetch(
			'https://lunarcrush.com/api4/public/coins/BTC/v1',
			{
				headers: {
					Authorization: `Bearer ${apiKey}`,
					'Content-Type': 'application/json',
				},
			}
		);

		if (!testResponse.ok) {
			const errorText = await testResponse.text();
			return c.json({
				success: false,
				error: 'API key authentication failed',
				api_key_length: apiKey.length,
				api_key_prefix: apiKey.substring(0, 10) + '...',
				lunarcrush_status: testResponse.status,
				lunarcrush_error: errorText,
				timestamp: new Date().toISOString(),
			});
		}

		const testData = (await testResponse.json()) as any;

		return c.json({
			success: true,
			message: 'API key is working correctly!',
			api_key_length: apiKey.length,
			api_key_prefix: apiKey.substring(0, 10) + '...',
			lunarcrush_test: {
				status: testResponse.status,
				bitcoin_price: testData.data?.price || 'Not found',
			},
			timestamp: new Date().toISOString(),
		});
	} catch (error) {
		console.error('API key test error:', error);
		return c.json({
			success: false,
			error: error instanceof Error ? error.message : String(error),
			stack: error instanceof Error ? error.stack : undefined,
			timestamp: new Date().toISOString(),
		});
	}
});

// ===== GRAPHQL ENDPOINT =====
app.all('/graphql', async (c) => {
	try {
		// Get API key using correct binding method
		const apiKey = await c.env.LUNARCRUSH_API_KEY.get();

		if (!apiKey) {
			return c.json(
				{
					error: 'LunarCrush API key not configured',
				},
				500
			);
		}

		// Create GraphQL server with API key
		const server = await createGraphQLServer({ apiKey });

		// Handle the GraphQL request
		return await handleGraphQLRequest(server, c.req.raw);
	} catch (error) {
		console.error('GraphQL error:', error);
		return c.json(
			{
				error: 'GraphQL server error',
				message: error instanceof Error ? error.message : String(error),
			},
			500
		);
	}
});

// ===== HEALTH CHECK =====
app.get('/health', (c) => {
	return c.json({
		status: 'healthy',
		timestamp: new Date().toISOString(),
		environment: 'production',
		version: '1.0.0',
		endpoints: {
			graphql: '/graphql',
			health: '/health',
			api_key_test: '/test-api-key',
		},
	});
});

// ===== LEGACY TEST ENDPOINTS (for backwards compatibility) =====
app.get('/test/secret', async (c) => {
	try {
		const apiKey = await c.env.LUNARCRUSH_API_KEY.get();
		return c.json({
			success: !!apiKey,
			api_key: apiKey,
			key_length: apiKey?.length || 0,
			timestamp: new Date().toISOString(),
		});
	} catch (error) {
		return c.json({
			success: false,
			error: error instanceof Error ? error.message : String(error),
			timestamp: new Date().toISOString(),
		});
	}
});

app.get('/test/lunarcrush', async (c) => {
	try {
		const apiKey = await c.env.LUNARCRUSH_API_KEY.get();

		if (!apiKey) {
			return c.json({
				success: false,
				error: 'API key not available',
			});
		}

		const response = await fetch(
			'https://lunarcrush.com/api4/public/coins/BTC/v1',
			{
				headers: {
					Authorization: `Bearer ${apiKey}`,
					'Content-Type': 'application/json',
				},
			}
		);

		if (!response.ok) {
			return c.json({
				success: false,
				error: `API request failed: ${response.status}`,
			});
		}

		const data = (await response.json()) as any;

		return c.json({
			success: true,
			lunarcrush: 'connected',
			btc_price: data.data?.price,
			data_sample: {
				symbol: data.data?.symbol,
				name: data.data?.name,
				price: data.data?.price,
				change_24h: data.data?.percent_change_24h,
				market_cap: data.data?.market_cap,
				galaxy_score: data.data?.galaxy_score,
				alt_rank: data.data?.alt_rank,
			},
		});
	} catch (error) {
		return c.json({
			success: false,
			error: error instanceof Error ? error.message : String(error),
		});
	}
});

export default {
	async fetch(request: Request, env: Environment): Promise<Response> {
		return app.fetch(request, env);
	},
};

=== LEGACY LUNARCRUSH SERVICE ===
File size:     1131 lines
// Complete LunarCrush service matching EXACT API documentation

export interface LunarCrushConfig {
	apiKey: string;
	baseUrl?: string;
}

export class LunarCrushError extends Error {
	constructor(
		message: string,
		public statusCode: number,
		public statusText: string
	) {
		super(message);
		this.name = 'LunarCrushError';
	}
}

// Core API request function
const makeRequest = async <T>(
	config: LunarCrushConfig,
	endpoint: string,
	params?: Record<string, any>
): Promise<T> => {
	const baseUrl = config.baseUrl || 'https://lunarcrush.com/api4/public';
	const url = new URL(`${baseUrl}${endpoint}`);

	if (params) {
		Object.entries(params)
			.filter(([_, value]) => value !== undefined && value !== null)
			.forEach(([key, value]) => url.searchParams.append(key, String(value)));
	}

	console.log(`🌙 LunarCrush API Request: ${url.toString()}`);

	const response = await fetch(url.toString(), {
		method: 'GET',
		headers: {
			Authorization: `Bearer ${config.apiKey}`,
			'Content-Type': 'application/json',
			Accept: 'application/json',
		},
	});

	if (!response.ok) {
		throw new LunarCrushError(
			`LunarCrush API error: ${response.status} ${response.statusText}`,
			response.status,
			response.statusText
		);
	}

	const responseData = (await response.json()) as T;
	console.log(`✅ LunarCrush response received`);
	return responseData;
};

// ===== TOPICS ENDPOINTS (EXACT FROM API DOCS) =====

export const getTopicsList = async (config: LunarCrushConfig): Promise<any> => {
	try {
		const response = await makeRequest<any>(config, '/topics/list/v1');
		return response.data;
	} catch (error) {
		console.error('❌ getTopicsList error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getTopic = async (
	config: LunarCrushConfig,
	topic: string
): Promise<any> => {
	try {
		const response = await makeRequest<any>(
			config,
			`/topic/${topic.toLowerCase()}/v1`
		);
		return response.data;
	} catch (error) {
		console.error('❌ getTopic error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getTopicWhatsup = async (
	config: LunarCrushConfig,
	topic: string
): Promise<any> => {
	try {
		const response = await makeRequest<any>(
			config,
			`/topic/${topic.toLowerCase()}/whatsup/v1`
		);
		return response;
	} catch (error) {
		console.error('❌ getTopicWhatsup error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getTopicTimeSeries = async (
	config: LunarCrushConfig,
	topic: string,
	bucket?: string,
	interval?: string,
	start?: string,
	end?: string
): Promise<any[]> => {
	try {
		const params: Record<string, any> = {};
		if (bucket) params.bucket = bucket;
		if (interval) params.interval = interval;
		if (start) params.start = start;
		if (end) params.end = end;

		const response = await makeRequest<any>(
			config,
			`/topic/${topic.toLowerCase()}/time-series/v1`,
			params
		);
		return response.data;
	} catch (error) {
		console.error('❌ getTopicTimeSeries error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getTopicTimeSeriesV2 = async (
	config: LunarCrushConfig,
	topic: string,
	bucket?: string
): Promise<any[]> => {
	try {
		const params: Record<string, any> = {};
		if (bucket) params.bucket = bucket;

		const response = await makeRequest<any>(
			config,
			`/topic/${topic.toLowerCase()}/time-series/v2`,
			params
		);
		return response.data;
	} catch (error) {
		console.error('❌ getTopicTimeSeriesV2 error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getTopicPosts = async (
	config: LunarCrushConfig,
	topic: string,
	start?: string,
	end?: string
): Promise<any[]> => {
	try {
		const params: Record<string, any> = {};
		if (start) params.start = start;
		if (end) params.end = end;

		const response = await makeRequest<any>(
			config,
			`/topic/${topic.toLowerCase()}/posts/v1`,
			params
		);
		return response.data;
	} catch (error) {
		console.error('❌ getTopicPosts error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getTopicNews = async (
	config: LunarCrushConfig,
	topic: string
): Promise<any[]> => {
	try {
		const response = await makeRequest<any>(
			config,
			`/topic/${topic.toLowerCase()}/news/v1`
		);
		return response.data;
	} catch (error) {
		console.error('❌ getTopicNews error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getTopicCreators = async (
	config: LunarCrushConfig,
	topic: string
): Promise<any[]> => {
	try {
		const response = await makeRequest<any>(
			config,
			`/topic/${topic.toLowerCase()}/creators/v1`
		);
		return response.data;
	} catch (error) {
		console.error('❌ getTopicCreators error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

// ===== CATEGORIES ENDPOINTS (EXACT FROM API DOCS) =====

export const getCategoriesList = async (
	config: LunarCrushConfig
): Promise<any[]> => {
	try {
		const response = await makeRequest<any>(config, '/categories/list/v1');
		return response.data;
	} catch (error) {
		console.error('❌ getCategoriesList error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getCategory = async (
	config: LunarCrushConfig,
	category: string
): Promise<any> => {
	try {
		const response = await makeRequest<any>(config, `/category/${category}/v1`);
		return response.data;
	} catch (error) {
		console.error('❌ getCategory error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getCategoryTopics = async (
	config: LunarCrushConfig,
	category: string
): Promise<any[]> => {
	try {
		const response = await makeRequest<any>(
			config,
			`/category/${category}/topics/v1`
		);
		return response.data;
	} catch (error) {
		console.error('❌ getCategoryTopics error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getCategoryTimeSeries = async (
	config: LunarCrushConfig,
	category: string,
	bucket?: string,
	interval?: string,
	start?: string,
	end?: string
): Promise<any[]> => {
	try {
		const params: Record<string, any> = {};
		if (bucket) params.bucket = bucket;
		if (interval) params.interval = interval;
		if (start) params.start = start;
		if (end) params.end = end;

		const response = await makeRequest<any>(
			config,
			`/category/${category}/time-series/v1`,
			params
		);
		return response.data;
	} catch (error) {
		console.error('❌ getCategoryTimeSeries error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getCategoryPosts = async (
	config: LunarCrushConfig,
	category: string,
	start?: string,
	end?: string
): Promise<any[]> => {
	try {
		const params: Record<string, any> = {};
		if (start) params.start = start;
		if (end) params.end = end;

		const response = await makeRequest<any>(
			config,
			`/category/${category}/posts/v1`,
			params
		);
		return response.data;
	} catch (error) {
		console.error('❌ getCategoryPosts error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getCategoryNews = async (
	config: LunarCrushConfig,
	category: string
): Promise<any[]> => {
	try {
		const response = await makeRequest<any>(
			config,
			`/category/${category}/news/v1`
		);
		return response.data;
	} catch (error) {
		console.error('❌ getCategoryNews error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getCategoryCreators = async (
	config: LunarCrushConfig,
	category: string
): Promise<any[]> => {
	try {
		const response = await makeRequest<any>(
			config,
			`/category/${category}/creators/v1`
		);
		return response.data;
	} catch (error) {
		console.error('❌ getCategoryCreators error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

// ===== CREATORS ENDPOINTS (EXACT FROM API DOCS) =====

export const getCreatorsList = async (
	config: LunarCrushConfig
): Promise<any[]> => {
	try {
		const response = await makeRequest<any>(config, '/creators/list/v1');
		return response.data;
	} catch (error) {
		console.error('❌ getCreatorsList error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getCreator = async (
	config: LunarCrushConfig,
	network: string,
	id: string
): Promise<any> => {
	try {
		const response = await makeRequest<any>(
			config,
			`/creator/${network}/${id}/v1`
		);
		return response.data;
	} catch (error) {
		console.error('❌ getCreator error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getCreatorTimeSeries = async (
	config: LunarCrushConfig,
	network: string,
	id: string,
	bucket?: string,
	interval?: string,
	start?: string,
	end?: string
): Promise<any[]> => {
	try {
		const params: Record<string, any> = {};
		if (bucket) params.bucket = bucket;
		if (interval) params.interval = interval;
		if (start) params.start = start;
		if (end) params.end = end;

		const response = await makeRequest<any>(
			config,
			`/creator/${network}/${id}/time-series/v1`,
			params
		);
		return response.data;
	} catch (error) {
		console.error('❌ getCreatorTimeSeries error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getCreatorPosts = async (
	config: LunarCrushConfig,
	network: string,
	id: string,
	start?: string,
	end?: string
): Promise<any[]> => {
	try {
		const params: Record<string, any> = {};
		if (start) params.start = start;
		if (end) params.end = end;

		const response = await makeRequest<any>(
			config,
			`/creator/${network}/${id}/posts/v1`,
			params
		);
		return response.data;
	} catch (error) {
		console.error('❌ getCreatorPosts error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

// ===== POSTS ENDPOINTS (EXACT FROM API DOCS) =====

export const getPostDetails = async (
	config: LunarCrushConfig,
	postType: string,
	postId: string
): Promise<any> => {
	try {
		const response = await makeRequest<any>(
			config,
			`/posts/${postType}/${postId}/v1`
		);
		return response;
	} catch (error) {
		console.error('❌ getPostDetails error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getPostTimeSeries = async (
	config: LunarCrushConfig,
	postType: string,
	postId: string
): Promise<any[]> => {
	try {
		const response = await makeRequest<any>(
			config,
			`/posts/${postType}/${postId}/time-series/v1`
		);
		return response.data;
	} catch (error) {
		console.error('❌ getPostTimeSeries error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

// ===== COINS ENDPOINTS (EXACT FROM API DOCS) =====

export const getCoinsList = async (
	config: LunarCrushConfig,
	sort?: string,
	filter?: string,
	limit?: number,
	desc?: string,
	page?: number
): Promise<any[]> => {
	try {
		const params: Record<string, any> = {};
		if (sort) params.sort = sort;
		if (filter) params.filter = filter;
		if (limit) params.limit = limit;
		if (desc) params.desc = desc;
		if (page) params.page = page;

		const response = await makeRequest<any>(config, '/coins/list/v1', params);
		return response.data;
	} catch (error) {
		console.error('❌ getCoinsList error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getCoinsListV2 = async (
	config: LunarCrushConfig,
	sort?: string,
	filter?: string,
	limit?: number,
	desc?: string,
	page?: number
): Promise<any[]> => {
	try {
		const params: Record<string, any> = {};
		if (sort) params.sort = sort;
		if (filter) params.filter = filter;
		if (limit) params.limit = limit;
		if (desc) params.desc = desc;
		if (page) params.page = page;

		const response = await makeRequest<any>(config, '/coins/list/v2', params);
		return response.data;
	} catch (error) {
		console.error('❌ getCoinsListV2 error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getCoin = async (
	config: LunarCrushConfig,
	coin: string
): Promise<any> => {
	try {
		const response = await makeRequest<any>(config, `/coins/${coin}/v1`);
		return response.data;
	} catch (error) {
		console.error('❌ getCoin error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getCoinTimeSeries = async (
	config: LunarCrushConfig,
	coin: string,
	bucket?: string,
	interval?: string,
	start?: string,
	end?: string
): Promise<any[]> => {
	try {
		const params: Record<string, any> = {};
		if (bucket) params.bucket = bucket;
		if (interval) params.interval = interval;
		if (start) params.start = start;
		if (end) params.end = end;

		const response = await makeRequest<any>(
			config,
			`/coins/${coin}/time-series/v2`,
			params
		);
		return response.data;
	} catch (error) {
		console.error('❌ getCoinTimeSeries error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getCoinMeta = async (
	config: LunarCrushConfig,
	coin: string
): Promise<any> => {
	try {
		const response = await makeRequest<any>(config, `/coins/${coin}/meta/v1`);
		return response.data;
	} catch (error) {
		console.error('❌ getCoinMeta error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

// ===== STOCKS ENDPOINTS (EXACT FROM API DOCS) =====

export const getStocksList = async (
	config: LunarCrushConfig,
	sort?: string,
	limit?: number,
	desc?: string,
	page?: number
): Promise<any[]> => {
	try {
		const params: Record<string, any> = {};
		if (sort) params.sort = sort;
		if (limit) params.limit = limit;
		if (desc) params.desc = desc;
		if (page) params.page = page;

		const response = await makeRequest<any>(config, '/stocks/list/v1', params);
		return response.data;
	} catch (error) {
		console.error('❌ getStocksList error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getStocksListV2 = async (
	config: LunarCrushConfig,
	sort?: string,
	limit?: number,
	desc?: string,
	page?: number
): Promise<any[]> => {
	try {
		const params: Record<string, any> = {};
		if (sort) params.sort = sort;
		if (limit) params.limit = limit;
		if (desc) params.desc = desc;
		if (page) params.page = page;

		const response = await makeRequest<any>(config, '/stocks/list/v2', params);
		return response.data;
	} catch (error) {
		console.error('❌ getStocksListV2 error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getStock = async (
	config: LunarCrushConfig,
	stock: string
): Promise<any> => {
	try {
		const response = await makeRequest<any>(config, `/stocks/${stock}/v1`);
		return response.data;
	} catch (error) {
		console.error('❌ getStock error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getStockTimeSeries = async (
	config: LunarCrushConfig,
	stock: string,
	bucket?: string,
	interval?: string,
	start?: string,
	end?: string
): Promise<any[]> => {
	try {
		const params: Record<string, any> = {};
		if (bucket) params.bucket = bucket;
		if (interval) params.interval = interval;
		if (start) params.start = start;
		if (end) params.end = end;

		const response = await makeRequest<any>(
			config,
			`/stocks/${stock}/time-series/v2`,
			params
		);
		return response.data;
	} catch (error) {
		console.error('❌ getStockTimeSeries error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

// ===== NFTS ENDPOINTS (EXACT FROM API DOCS) =====

export const getNftsList = async (
	config: LunarCrushConfig,
	sort?: string,
	limit?: number,
	desc?: string,
	page?: number
): Promise<any[]> => {
	try {
		const params: Record<string, any> = {};
		if (sort) params.sort = sort;
		if (limit) params.limit = limit;
		if (desc) params.desc = desc;
		if (page) params.page = page;

		const response = await makeRequest<any>(config, '/nfts/list/v1', params);
		return response.data;
	} catch (error) {
		console.error('❌ getNftsList error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getNftsListV2 = async (
	config: LunarCrushConfig,
	sort?: string,
	limit?: number,
	desc?: string,
	page?: number
): Promise<any[]> => {
	try {
		const params: Record<string, any> = {};
		if (sort) params.sort = sort;
		if (limit) params.limit = limit;
		if (desc) params.desc = desc;
		if (page) params.page = page;

		const response = await makeRequest<any>(config, '/nfts/list/v2', params);
		return response.data;
	} catch (error) {
		console.error('❌ getNftsListV2 error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getNft = async (
	config: LunarCrushConfig,
	nft: string
): Promise<any> => {
	try {
		const response = await makeRequest<any>(config, `/nfts/${nft}/v1`);
		return response.data;
	} catch (error) {
		console.error('❌ getNft error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getNftTimeSeries = async (
	config: LunarCrushConfig,
	nft: string,
	bucket?: string,
	interval?: string,
	start?: string,
	end?: string
): Promise<any[]> => {
	try {
		const params: Record<string, any> = {};
		if (bucket) params.bucket = bucket;
		if (interval) params.interval = interval;
		if (start) params.start = start;
		if (end) params.end = end;

		const response = await makeRequest<any>(
			config,
			`/nfts/${nft}/time-series/v2`,
			params
		);
		return response.data;
	} catch (error) {
		console.error('❌ getNftTimeSeries error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getNftTimeSeriesV1 = async (
	config: LunarCrushConfig,
	nft: string
): Promise<any> => {
	try {
		const response = await makeRequest<any>(
			config,
			`/nfts/${nft}/time-series/v1`
		);
		return response;
	} catch (error) {
		console.error('❌ getNftTimeSeriesV1 error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

// ===== SYSTEM ENDPOINTS (EXACT FROM API DOCS) =====

export const getSystemChanges = async (
	config: LunarCrushConfig
): Promise<any[]> => {
	try {
		const response = await makeRequest<any>(config, '/system/changes');
		return response.data;
	} catch (error) {
		console.error('❌ getSystemChanges error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

// ===== SEARCHES ENDPOINTS (EXACT FROM API DOCS) =====

export const getSearchesList = async (
	config: LunarCrushConfig
): Promise<any[]> => {
	try {
		const response = await makeRequest<any>(config, '/searches/list');
		return response.data;
	} catch (error) {
		console.error('❌ getSearchesList error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const getSearch = async (
	config: LunarCrushConfig,
	slug: string
): Promise<any> => {
	try {
		const response = await makeRequest<any>(config, `/searches/${slug}`);
		return response;
	} catch (error) {
		console.error('❌ getSearch error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

export const searchPosts = async (
	config: LunarCrushConfig,
	term?: string,
	searchJson?: string
): Promise<any> => {
	try {
		const params: Record<string, any> = {};
		if (term) params.term = term;
		if (searchJson) params.search_json = searchJson;

		const response = await makeRequest<any>(config, '/searches/search', params);
		return response;
	} catch (error) {
		console.error('❌ searchPosts error:', error);
		if (error instanceof LunarCrushError) {
			throw new Error(
				`${error.statusCode} ${error.statusText}: ${error.message}`
			);
		}
		throw error;
	}
};

// ===== CLIENT FACTORY WITH ALL EXACT ENDPOINTS =====
export const createLunarCrushClient = (config: LunarCrushConfig) => ({
	// TOPICS ENDPOINTS
	getTopicsList: () => getTopicsList(config),
	getTopic: (topic: string) => getTopic(config, topic),
	getTopicWhatsup: (topic: string) => getTopicWhatsup(config, topic),
	getTopicTimeSeries: (
		topic: string,
		bucket?: string,
		interval?: string,
		start?: string,
		end?: string
	) => getTopicTimeSeries(config, topic, bucket, interval, start, end),
	getTopicTimeSeriesV2: (topic: string, bucket?: string) =>
		getTopicTimeSeriesV2(config, topic, bucket),
	getTopicPosts: (topic: string, start?: string, end?: string) =>
		getTopicPosts(config, topic, start, end),
	getTopicNews: (topic: string) => getTopicNews(config, topic),
	getTopicCreators: (topic: string) => getTopicCreators(config, topic),

	// CATEGORIES ENDPOINTS
	getCategoriesList: () => getCategoriesList(config),
	getCategory: (category: string) => getCategory(config, category),
	getCategoryTopics: (category: string) => getCategoryTopics(config, category),
	getCategoryTimeSeries: (
		category: string,
		bucket?: string,
		interval?: string,
		start?: string,
		end?: string
	) => getCategoryTimeSeries(config, category, bucket, interval, start, end),
	getCategoryPosts: (category: string, start?: string, end?: string) =>
		getCategoryPosts(config, category, start, end),
	getCategoryNews: (category: string) => getCategoryNews(config, category),
	getCategoryCreators: (category: string) =>
		getCategoryCreators(config, category),

	// CREATORS ENDPOINTS
	getCreatorsList: () => getCreatorsList(config),
	getCreator: (network: string, id: string) => getCreator(config, network, id),
	getCreatorTimeSeries: (
		network: string,
		id: string,
		bucket?: string,
		interval?: string,
		start?: string,
		end?: string
	) => getCreatorTimeSeries(config, network, id, bucket, interval, start, end),
	getCreatorPosts: (
		network: string,
		id: string,
		start?: string,
		end?: string
	) => getCreatorPosts(config, network, id, start, end),

	// POSTS ENDPOINTS
	getPostDetails: (postType: string, postId: string) =>
		getPostDetails(config, postType, postId),
	getPostTimeSeries: (postType: string, postId: string) =>
		getPostTimeSeries(config, postType, postId),

	// COINS ENDPOINTS
	getCoinsList: (
		sort?: string,
		filter?: string,
		limit?: number,
		desc?: string,
		page?: number
	) => getCoinsList(config, sort, filter, limit, desc, page),
	getCoinsListV2: (
		sort?: string,
		filter?: string,
		limit?: number,
		desc?: string,
		page?: number
	) => getCoinsListV2(config, sort, filter, limit, desc, page),
	getCoin: (coin: string) => getCoin(config, coin),
	getCoinTimeSeries: (
		coin: string,
		bucket?: string,
		interval?: string,
		start?: string,
		end?: string
	) => getCoinTimeSeries(config, coin, bucket, interval, start, end),
	getCoinMeta: (coin: string) => getCoinMeta(config, coin),

	// STOCKS ENDPOINTS
	getStocksList: (
		sort?: string,
		limit?: number,
		desc?: string,
		page?: number
	) => getStocksList(config, sort, limit, desc, page),
	getStocksListV2: (
		sort?: string,
		limit?: number,
		desc?: string,
		page?: number
	) => getStocksListV2(config, sort, limit, desc, page),
	getStock: (stock: string) => getStock(config, stock),
	getStockTimeSeries: (
		stock: string,
		bucket?: string,
		interval?: string,
		start?: string,
		end?: string
	) => getStockTimeSeries(config, stock, bucket, interval, start, end),

	// NFTS ENDPOINTS
	getNftsList: (sort?: string, limit?: number, desc?: string, page?: number) =>
		getNftsList(config, sort, limit, desc, page),
	getNftsListV2: (
		sort?: string,
		limit?: number,
		desc?: string,
		page?: number
	) => getNftsListV2(config, sort, limit, desc, page),
	getNft: (nft: string) => getNft(config, nft),
	getNftTimeSeries: (
		nft: string,
		bucket?: string,
		interval?: string,
		start?: string,
		end?: string
	) => getNftTimeSeries(config, nft, bucket, interval, start, end),
	getNftTimeSeriesV1: (nft: string) => getNftTimeSeriesV1(config, nft),

	// SYSTEM ENDPOINTS
	getSystemChanges: () => getSystemChanges(config),

	// SEARCHES ENDPOINTS
	getSearchesList: () => getSearchesList(config),
	getSearch: (slug: string) => getSearch(config, slug),
	searchPosts: (term?: string, searchJson?: string) =>
		searchPosts(config, term, searchJson),
});

export type LunarCrushClient = ReturnType<typeof createLunarCrushClient>;

