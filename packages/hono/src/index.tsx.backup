import { Hono } from 'hono'
import { cors } from 'hono/cors'
import { buildSchema, graphql } from 'graphql'

// üî• Enhanced Security & DX Middleware
import { logger } from 'hono/logger'
import { requestId } from 'hono/request-id'
import { secureHeaders } from 'hono/secure-headers'
import { prettyJSON } from 'hono/pretty-json'
import { HTTPException } from 'hono/http-exception'
import { bodyLimit } from 'hono/body-limit'
// import { compress } from 'hono/compress'
import { timeout } from 'hono/timeout'
import { etag } from 'hono/etag'
import { timing } from 'hono/timing'
import { cache } from 'hono/cache'
import { contextStorage } from 'hono/context-storage'
import { bearerAuth } from 'hono/bearer-auth'

// üç™ NEW: Cookie Management
import { getCookie, setCookie, deleteCookie, getSignedCookie, setSignedCookie } from 'hono/cookie'

// üöÄ NEW: Streaming & Real-time
import { streamText, streamSSE } from 'hono/streaming'

// üéØ NEW: Enhanced Validation
import { zValidator } from '@hono/zod-validator'
import { validator } from 'hono/validator'
import { z } from 'zod'

// üîß NEW: Advanced Middleware Combinations
import { some, every, except } from 'hono/combine'

// üé® NEW: JSX Support
/** @jsx jsx */
/** @jsxImportSource hono/jsx */
import { jsx } from 'hono/jsx'
import { html } from 'hono/html'

// üß™ NEW: Testing Support (for development)
import { testClient } from 'hono/testing'


type Bindings = {
  JWT_SECRET: string
  LUNARCRUSH_API_KEY: string
  LUNARCRUSH_CACHE: KVNamespace
  DB: D1Database
  ENVIRONMENT?: string
}

type JWTPayload = {
  sub: string
  type: 'demo' | 'personal' | 'admin'
  apiKey?: string
  iat: number
  exp: number
}

// Enhanced Variables with more types
type Variables = {
  requestId: string
  user?: JWTPayload
  userAgent?: string
  clientIP?: string
  startTime?: number
}

const app = new Hono<{
  Bindings: Bindings
  Variables: Variables
}>()

// üç™ Cookie Secret for signed cookies
const COOKIE_SECRET = 'your-cookie-secret-key' // In production, use env variable

// Cache helpers (keep existing implementation)
const memoryCache = new Map<string, { value: string, expires: number }>()

const cacheGet = async (cache: KVNamespace | undefined, key: string): Promise<string | null> => {
  if (cache) {
    try {
      return await cache.get(key)
    } catch (error) {
      console.warn('KV get failed, using memory cache:', error)
    }
  }

  const item = memoryCache.get(key)
  if (item && item.expires > Date.now()) {
    return item.value
  }
  memoryCache.delete(key)
  return null
}

const cachePut = async (cache: KVNamespace | undefined, key: string, value: string, ttl: number): Promise<void> => {
  if (cache) {
    try {
      await cache.put(key, value, { expirationTtl: ttl })
      return
    } catch (error) {
      console.warn('KV put failed, using memory cache:', error)
    }
  }

  memoryCache.set(key, { value, expires: Date.now() + (ttl * 1000) })
}

// üî• ENHANCED: Essential Middleware Stack
app.use(timing()) // Performance monitoring
app.use(contextStorage()) // Context sharing

// üîß Advanced Middleware - Request context enhancement
app.use('*', async (c, next) => {
  c.set('startTime', Date.now())
  c.set('userAgent', c.req.header('User-Agent') || 'unknown')
  c.set('clientIP', c.req.header('CF-Connecting-IP') || c.req.header('X-Forwarded-For') || 'unknown')
  await next()
})

// Cache middleware with custom configuration
app.use('/api/cached/*', cache({
  cacheName: 'lunarcrush-api-cache',
  cacheControl: 'max-age=300', // 5 minutes
  vary: ['Accept-Encoding', 'Authorization'],
  keyGenerator: (c) => `${c.req.method}-${c.req.url}-${c.req.header('Authorization')?.slice(0, 20) || 'anon'}`
}))

// Body limit with enhanced error handling
app.use(bodyLimit({
  maxSize: 50 * 1024 * 1024, // 50MB
  onError: (c) => {
    const size = c.req.header('content-length')
    console.warn(`[${c.get('requestId')}] Request body too large: ${size} bytes`)
    throw new HTTPException(413, {
      message: 'Payload Too Large - Request body exceeds 50MB limit',
      cause: { size, limit: '50MB' }
    })
  }
}))

// Compress with optimal settings
// app.use(compress({ encoding: \'gzip\', threshold: 1024 }))

// Timeout with context-aware errors
app.use(timeout(30000, (c) => {
  const elapsed = Date.now() - (c.get('startTime') || Date.now())
  console.warn(`[${c.get('requestId')}] Request timeout after ${elapsed}ms: ${c.req.method} ${c.req.path}`)
  throw new HTTPException(408, {
    message: 'Request Timeout - Request took longer than 30 seconds',
    cause: { elapsed, path: c.req.path, method: c.req.method }
  })
}))

app.use(etag()) // Caching optimizations
app.use(logger()) // Request logging
app.use(requestId()) // Request tracing
app.use(secureHeaders()) // Security headers
app.use(prettyJSON()) // Pretty JSON responses

// CORS configuration
app.use('/*', cors({
  origin: ['http://localhost:3000', 'http://localhost:5173', 'https://lunarcrush.cryptoguard-api.workers.dev', '*'],
  allowHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'X-User-Preferences'],
  allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  credentials: true,
}))

// üîê NEW: Enhanced Authentication Middleware
const enhancedAuth = some(
  // Admin routes - require specific token
  every(
    bearerAuth({
      token: async (token, c) => {
        try {
          const { verify } = await import('hono/jwt')
          const payload = await verify(token, c.env.JWT_SECRET) as JWTPayload
          if (payload.type === 'admin') {
            c.set('user', payload)
            return true
          }
          return false
        } catch {
          return false
        }
      }
    })
  ),
  // Regular auth - any valid token
  bearerAuth({
    token: async (token, c) => {
      try {
        const { verify } = await import('hono/jwt')
        const payload = await verify(token, c.env.JWT_SECRET) as JWTPayload
        c.set('user', payload)
        return true
      } catch {
        return false
      }
    }
  })
)

// üéØ NEW: Validation Schemas
const TopicQuerySchema = z.object({
  topic: z.string().min(1).max(50),
  timeframe: z.enum(['1h', '24h', '7d', '30d']).optional().default('24h'),
  includeRaw: z.string().transform(val => val === 'true').optional().default(false)
})

const UserPreferencesSchema = z.object({
  theme: z.enum(['light', 'dark', 'auto']).optional(),
  currency: z.enum(['USD', 'EUR', 'BTC', 'ETH']).optional(),
  notifications: z.boolean().optional(),
  favoriteTopics: z.array(z.string()).optional()
})

const CreateTopicSchema = z.object({
  topic: z.string().min(1).max(50),
  category: z.string().min(1).max(30),
  description: z.string().optional()
})

// üî• Enhanced GraphQL Schema
const schema = buildSchema(`
  type Query {
    hello: String!
    health: HealthStatus!
    user: User
    getTopic(topic: String!): TopicData!
    getTopicsList: [Topic!]!
    getUserPreferences: UserPreferences
  }

  type Mutation {
    generateDemoToken: TokenResponse!
    updateUserPreferences(input: UserPreferencesInput!): UserPreferences!
    createTopic(input: CreateTopicInput!): Topic!
  }

  type HealthStatus {
    status: String!
    timestamp: String!
    service: String!
    version: String!
    requestId: String!
    uptime: Float!
    features: [String!]!
  }

  type User {
    id: String!
    type: String!
    lastSeen: String!
  }

  type TopicData {
    symbol: String!
    name: String!
    price: Float!
    sentiment: Float
    socialScore: Float
    raw: String!
  }

  type Topic {
    topic: String!
    category: String!
    description: String
    createdAt: String!
  }

  type UserPreferences {
    theme: String
    currency: String
    notifications: Boolean
    favoriteTopics: [String!]
  }

  type TokenResponse {
    token: String!
    user: User!
    expiresIn: String!
  }

  input UserPreferencesInput {
    theme: String
    currency: String
    notifications: Boolean
    favoriteTopics: [String!]
  }

  input CreateTopicInput {
    topic: String!
    category: String!
    description: String
  }
`)

// üî• Enhanced GraphQL Resolvers
const resolvers = {
  hello: () => 'Hello from Enhanced LunarCrush Universal Hono! üöÄ',

  health: (args: any, context: any) => ({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    service: 'lunarcrush-universal-hono-enhanced',
    version: '2.0.0',
    requestId: context.requestId || 'unknown',
    uptime: process.uptime ? process.uptime() : 0,
    features: [
      'GraphQL', 'REST', 'Streaming', 'SSE', 'Cookies', 'JWT',
      'Rate Limiting', 'Caching', 'Validation', 'JSX', 'Testing'
    ]
  }),

  user: (args: any, context: any) => {
    if (!context.user) {
      throw new HTTPException(401, { message: 'Authentication required' })
    }
    return {
      id: context.user.sub,
      type: context.user.type,
      lastSeen: new Date().toISOString()
    }
  },

  getTopic: async (args: any, context: any) => {
    const { topic } = args
    // Simulate enhanced topic data
    return {
      symbol: topic.toUpperCase(),
      name: topic.charAt(0).toUpperCase() + topic.slice(1),
      price: Math.random() * 50000,
      sentiment: Math.random() * 100,
      socialScore: Math.random() * 1000,
      raw: JSON.stringify({
        enhanced: true,
        topic,
        timestamp: new Date().toISOString(),
        requestId: context.requestId
      })
    }
  },

  getTopicsList: () => [
    { topic: 'bitcoin', category: 'crypto', description: 'Digital gold', createdAt: new Date().toISOString() },
    { topic: 'ethereum', category: 'crypto', description: 'Smart contracts platform', createdAt: new Date().toISOString() },
    { topic: 'solana', category: 'crypto', description: 'High-performance blockchain', createdAt: new Date().toISOString() }
  ],

  getUserPreferences: (args: any, context: any) => {
    if (!context.user) {
      throw new HTTPException(401, { message: 'Authentication required' })
    }
    // Return mock preferences (in real app, fetch from DB)
    return {
      theme: 'dark',
      currency: 'USD',
      notifications: true,
      favoriteTopics: ['bitcoin', 'ethereum']
    }
  },

  generateDemoToken: async (args: any, context: any) => {
    const { sign } = await import('hono/jwt')
    const payload = {
      sub: `demo_${Date.now()}`,
      type: 'demo' as const,
      iat: Math.floor(Date.now() / 1000),
      exp: Math.floor(Date.now() / 1000) + (7 * 24 * 60 * 60),
    }
    const token = await sign(payload, context.env.JWT_SECRET)
    return {
      token,
      user: { id: payload.sub, type: payload.type, lastSeen: new Date().toISOString() },
      expiresIn: '7 days'
    }
  },

  updateUserPreferences: async (args: any, context: any) => {
    if (!context.user) {
      throw new HTTPException(401, { message: 'Authentication required' })
    }
    // In real app, save to database
    return args.input
  },

  createTopic: async (args: any, context: any) => {
    if (!context.user) {
      throw new HTTPException(401, { message: 'Authentication required' })
    }
    return {
      ...args.input,
      createdAt: new Date().toISOString()
    }
  }
}

// üî• Enhanced Health Endpoint
app.get('/health', (c) => {
  const startTime = c.get('startTime') || Date.now()
  return c.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    service: 'lunarcrush-universal-hono-enhanced',
    version: '2.0.0',
    environment: c.env.ENVIRONMENT || 'development',
    requestId: c.get('requestId'),
    client: {
      ip: c.get('clientIP'),
      userAgent: c.get('userAgent')
    },
    performance: {
      responseTime: Date.now() - startTime
    },
    features: {
      security: ['secureHeaders', 'cors', 'rateLimit', 'jwt'],
      middleware: ['compression', 'caching', 'timeout', 'etag'],
      apis: ['graphql', 'rest', 'streaming', 'sse'],
      validation: ['zod', 'multiTarget'],
      cookies: ['signed', 'secure'],
      rendering: ['jsx', 'html']
    },
    bindings: {
      jwt_secret: !!c.env.JWT_SECRET,
      api_key: !!c.env.LUNARCRUSH_API_KEY,
      cache: !!c.env.LUNARCRUSH_CACHE,
      database: !!c.env.DB
    }
  })
})



// üîê Demo Token Generation REST Endpoint
app.post('/auth/demo-token', async (c) => {
  try {
    const { sign } = await import('hono/jwt')
    const payload = {
      sub: `demo_${Date.now()}`,
      type: 'demo' as const,
      iat: Math.floor(Date.now() / 1000),
      exp: Math.floor(Date.now() / 1000) + (7 * 24 * 60 * 60),
    }
    const token = await sign(payload, c.env.JWT_SECRET)

    return c.json({
      success: true,
      token,
      user: {
        id: payload.sub,
        type: payload.type,
        lastSeen: new Date().toISOString()
      },
      expiresIn: '7 days',
      requestId: c.get('requestId')
    })
  } catch (error) {
    console.error('Demo token generation error:', error)
    throw new HTTPException(500, {
      message: 'Failed to generate demo token',
      cause: error
    })
  }
})

// üç™ NEW: Cookie Management Endpoints
app.get('/api/cookies/demo', async (c) => {
  // Set various types of cookies
  setCookie(c, 'demo-cookie', 'hello-world', {
    maxAge: 3600,
    secure: true,
    httpOnly: true,
    sameSite: 'Strict'
  })

  await setSignedCookie(c, 'signed-demo', 'secure-value', COOKIE_SECRET, {
    maxAge: 3600,
    secure: true
  })

  setCookie(c, 'user-preferences', JSON.stringify({
    theme: 'dark',
    currency: 'USD'
  }), {
    maxAge: 86400 * 30, // 30 days
    secure: true
  })

  return c.json({
    message: 'Demo cookies set',
    cookies: ['demo-cookie', 'signed-demo', 'user-preferences'],
    requestId: c.get('requestId')
  })
})

app.get('/api/cookies/read', async (c) => {
  const demoCookie = getCookie(c, 'demo-cookie')
  const signedDemo = await getSignedCookie(c, COOKIE_SECRET, 'signed-demo')
  const preferences = getCookie(c, 'user-preferences')

  return c.json({
    cookies: {
      demo: demoCookie,
      signed: signedDemo,
      preferences: preferences ? JSON.parse(preferences) : null
    },
    requestId: c.get('requestId')
  })
})

// üöÄ NEW: Streaming & Server-Sent Events
app.get('/api/stream/text', (c) => {
  return streamText(c, async (stream) => {
    await stream.writeln('üöÄ Starting LunarCrush data stream...')
    await stream.sleep(1000)

    for (let i = 1; i <= 5; i++) {
      await stream.writeln(`üìä Data packet ${i}: BTC Price: $${(Math.random() * 50000 + 30000).toFixed(2)}`)
      await stream.sleep(1000)
    }

    await stream.writeln('‚úÖ Stream completed!')
  })
})

app.get('/api/stream/sse/crypto/:symbol', (c) => {
  const symbol = c.req.param('symbol').toUpperCase()

  return streamSSE(c, async (stream) => {
    let id = 0

    // Set up SSE headers
    stream.onAbort(() => {
      console.log(`SSE stream aborted for ${symbol}`)
    })

    while (true) {
      const price = Math.random() * 50000 + 30000
      const sentiment = Math.random() * 100
      const volume = Math.random() * 1000000

      await stream.writeSSE({
        data: JSON.stringify({
          symbol,
          price: price.toFixed(2),
          sentiment: sentiment.toFixed(1),
          volume: volume.toFixed(0),
          timestamp: new Date().toISOString(),
          change24h: ((Math.random() - 0.5) * 20).toFixed(2)
        }),
        event: 'crypto-update',
        id: String(id++),
      })

      await stream.sleep(2000) // Update every 2 seconds
    }
  })
})

// üéØ NEW: Multi-target Validation Examples
app.post('/api/validate/topic',
  zValidator('json', CreateTopicSchema),
  zValidator('header', z.object({
    'authorization': z.string().startsWith('Bearer '),
    'content-type': z.literal('application/json')
  })),
  validator('query', (value, c) => {
    const includeRaw = value['includeRaw']
    if (includeRaw && !['true', 'false'].includes(includeRaw)) {
      return c.text('includeRaw must be true or false', 400)
    }
    return { includeRaw: includeRaw === 'true' }
  }),
  (c) => {
    const jsonData = c.req.valid('json')
    const headers = c.req.valid('header')
    const query = c.req.valid('query')

    return c.json({
      message: 'Multi-target validation successful!',
      validated: {
        json: jsonData,
        headers: Object.keys(headers),
        query: query
      },
      requestId: c.get('requestId')
    })
  }
)

// üé® NEW: JSX Rendering Examples
app.get('/ui/demo', (c) => {
  const userAgent = c.get('userAgent')
  const requestId = c.get('requestId')

  return c.html(
    <html>
      <head>
        <title>LunarCrush Universal API - Demo</title>
        <style>{`
          body { font-family: system-ui; margin: 40px; background: #0f0f0f; color: #fff; }
          .container { max-width: 800px; margin: 0 auto; }
          .card { background: #1a1a1a; padding: 20px; border-radius: 8px; margin: 20px 0; }
          .code { background: #2a2a2a; padding: 10px; border-radius: 4px; font-family: monospace; }
          .badge { background: #4ade80; color: #000; padding: 4px 8px; border-radius: 4px; font-size: 12px; }
        `}</style>
      </head>
      <body>
        <div class="container">
          <h1>üöÄ LunarCrush Universal API</h1>
          <div class="card">
            <h2>Enhanced Features <span class="badge">ACTIVE</span></h2>
            <ul>
              <li>‚úÖ GraphQL API with enhanced schema</li>
              <li>‚úÖ REST API with advanced validation</li>
              <li>‚úÖ Server-Sent Events for real-time data</li>
              <li>‚úÖ Cookie management (signed & secure)</li>
              <li>‚úÖ JWT authentication with multiple user types</li>
              <li>‚úÖ Advanced middleware combinations</li>
              <li>‚úÖ JSX rendering support</li>
            </ul>
          </div>

          <div class="card">
            <h3>Request Information</h3>
            <div class="code">
              Request ID: {requestId}<br/>
              User Agent: {userAgent}<br/>
              Timestamp: {new Date().toISOString()}
            </div>
          </div>

          <div class="card">
            <h3>Try These Endpoints</h3>
            <ul>
              <li><code>GET /graphql</code> - GraphiQL interface</li>
              <li><code>GET /api/stream/sse/crypto/bitcoin</code> - Live crypto data</li>
              <li><code>GET /api/cookies/demo</code> - Cookie management demo</li>
              <li><code>POST /api/validate/topic</code> - Multi-target validation</li>
            </ul>
          </div>
        </div>
      </body>
    </html>
  )
})


// üîê Protected routes with advanced auth
app.use('/api/admin/*', enhancedAuth)

app.get('/api/admin/stats', (c) => {
  const user = c.get('user')
  return c.json({
    message: 'Admin stats',
    admin: user,
    stats: {
      totalRequests: Math.floor(Math.random() * 10000),
      activeUsers: Math.floor(Math.random() * 100),
      cacheHits: Math.floor(Math.random() * 5000)
    },
    requestId: c.get('requestId')
  })
})

// üö¶ Enhanced Rate Limiting
const enhancedRateLimit = async (c: any, next: any) => {
  try {
    const authHeader = c.req.header('Authorization')
    let userId = 'anonymous'
    let rateLimit = 5 // Default for anonymous

    if (authHeader?.startsWith('Bearer ')) {
      try {
        const token = authHeader.slice(7)
        const { verify } = await import('hono/jwt')
        const payload = await verify(token, c.env.JWT_SECRET) as JWTPayload
        userId = payload.sub
        c.set('user', payload)

        // Different limits by user type
        rateLimit = payload.type === 'admin' ? 100 : payload.type === 'personal' ? 20 : 10
      } catch {
        userId = 'anonymous'
      }
    }

    const minute = Math.floor(Date.now() / 60000)
    const key = `rate_${userId}_${minute}`

    const current = await cacheGet(c.env.LUNARCRUSH_CACHE, key)
    const count = current ? parseInt(current) : 0

    if (count >= rateLimit) {
      throw new HTTPException(429, {
        message: 'Rate limit exceeded',
        cause: {
          count,
          limit: rateLimit,
          userType: c.get('user')?.type || 'anonymous',
          resetInSeconds: Math.round(60 - (Date.now() % 60000) / 1000)
        }
      })
    }

    await cachePut(c.env.LUNARCRUSH_CACHE, key, (count + 1).toString(), 60)

    // Add rate limit headers
    c.header('X-RateLimit-Limit', rateLimit.toString())
    c.header('X-RateLimit-Remaining', (rateLimit - count - 1).toString())
    c.header('X-RateLimit-Reset', (Math.floor(Date.now() / 1000) + 60).toString())

    await next()
  } catch (error) {
    if (error instanceof HTTPException) {
      throw error
    }
    console.error('Rate limiting error:', error)
    await next()
  }
}

// Apply enhanced rate limiting to API routes
app.use('/api/*', enhancedRateLimit)

// üéØ Enhanced GraphQL Endpoint
app.post('/graphql', async (c) => {
  try {
    const body = await c.req.json()
    const { query, variables = {}, operationName } = body

    console.log('üîç GraphQL request:', {
      query: query?.substring(0, 100) + '...',
      variables,
      operationName,
      requestId: c.get('requestId')
    })

    // Enhanced context with more data
    const context = {
      env: c.env,
      user: c.get('user'),
      request: c.req,
      requestId: c.get('requestId'),
      clientIP: c.get('clientIP'),
      userAgent: c.get('userAgent'),
      startTime: c.get('startTime')
    }

    const result = await graphql({
      schema,
      source: query,
      rootValue: resolvers,
      contextValue: context,
      variableValues: variables,
      operationName
    })

    // Add performance timing
    const responseTime = Date.now() - (c.get('startTime') || Date.now())
    if (result.extensions) {
      result.extensions.timing = { responseTime }
    } else {
      result.extensions = { timing: { responseTime } }
    }

    return c.json(result)
  } catch (error) {
    console.error('‚ùå GraphQL error:', error)
    if (error instanceof HTTPException) {
      return error.getResponse()
    }
    throw new HTTPException(500, {
      message: 'GraphQL execution failed',
      cause: error
    })
  }
})

// Enhanced GraphiQL Interface
app.get('/graphql', (c) => {
  const requestId = c.get('requestId')
  const userAgent = c.get('userAgent')

  return c.html(`
<!DOCTYPE html>
<html>
<head>
  <title>GraphiQL - Enhanced LunarCrush Universal API</title>
  <link href="https://unpkg.com/graphiql@3.0.6/graphiql.min.css" rel="stylesheet" />
  <style>
    body { margin: 0; font-family: system-ui; }
    #graphiql { height: 100vh; }
    .title { background: #1a1a1a; color: #fff; padding: 10px; font-size: 18px; display: flex; justify-content: space-between; align-items: center; }
    .request-info { background: #2a2a2a; color: #ccc; padding: 5px 10px; font-size: 12px; }
    .features { background: #4ade80; color: #000; padding: 2px 8px; border-radius: 4px; font-size: 11px; margin-left: 10px; }
  </style>
</head>
<body>
  <div class="title">
    <span>üöÄ Enhanced LunarCrush Universal API - GraphiQL</span>
    <span class="features">STREAMING ‚Ä¢ COOKIES ‚Ä¢ VALIDATION ‚Ä¢ JSX</span>
  </div>
  <div class="request-info">
    Request ID: ${requestId} | User Agent: ${userAgent?.substring(0, 50)}... | Features: All Enhanced
  </div>
  <div id="graphiql"></div>

  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/graphiql@3.0.6/graphiql.min.js"></script>

  <script>
    const fetcher = (graphQLParams) => {
      return fetch('/graphql', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          // Add Authorization header if you have a token
          // 'Authorization': 'Bearer YOUR_TOKEN_HERE'
        },
        body: JSON.stringify(graphQLParams),
      }).then(response => response.json());
    };

    const root = ReactDOM.createRoot(document.getElementById('graphiql'));
    root.render(
      React.createElement(GraphiQL, {
        fetcher: fetcher,
        defaultQuery: \`# üöÄ Enhanced LunarCrush Universal API
# Request ID: ${requestId}

# Basic queries
{
  hello
  health {
    status
    timestamp
    service
    version
    requestId
    uptime
    features
  }
}

# With authentication (add Authorization header):
# {
#   user {
#     id
#     type
#     lastSeen
#   }
#   getUserPreferences {
#     theme
#     currency
#     notifications
#     favoriteTopics
#   }
# }

# Create demo token:
# mutation {
#   generateDemoToken {
#     token
#     user { id type }
#     expiresIn
#   }
# }

# Enhanced topic query:
# {
#   getTopic(topic: "bitcoin") {
#     symbol
#     name
#     price
#     sentiment
#     socialScore
#     raw
#   }
# }\`
      })
    );
  </script>
</body>
</html>`)
})

// üî• Enhanced Error Handler
app.onError((err, c) => {
  const requestId = c.get('requestId') || 'unknown'
  const startTime = c.get('startTime') || Date.now()
  const responseTime = Date.now() - startTime

  console.error(`[${requestId}] Error after ${responseTime}ms:`, {
    message: err.message,
    stack: err.stack?.substring(0, 500),
    url: c.req.url,
    method: c.req.method,
    userAgent: c.get('userAgent'),
    clientIP: c.get('clientIP'),
    timestamp: new Date().toISOString()
  })

  // Handle HTTPException with enhanced response
  if (err instanceof HTTPException) {
    const response = err.getResponse()
    // Try to add extra context to JSON responses
    if (response.headers.get('content-type')?.includes('application/json')) {
      return response
    }
    // Enhance non-JSON HTTPException responses
    return c.json({
      error: 'HTTP Exception',
      message: err.message,
      status: err.status,
      requestId,
      timestamp: new Date().toISOString(),
      responseTime,
      cause: err.cause
    }, err.status)
  }

  // Enhanced error categorization
  if (err.message?.includes('Rate limit')) {
    return c.json({
      error: 'Rate Limit Exceeded',
      message: 'Too many requests. Please try again later.',
      requestId,
      type: 'RATE_LIMIT_ERROR',
      timestamp: new Date().toISOString(),
      responseTime
    }, 429)
  }

  if (err.message?.includes('auth') || err.message?.includes('token')) {
    return c.json({
      error: 'Authentication Error',
      message: 'Invalid or missing authentication credentials.',
      requestId,
      type: 'AUTH_ERROR',
      timestamp: new Date().toISOString(),
      responseTime
    }, 401)
  }

  if (err.message?.includes('validation') || err.message?.includes('invalid')) {
    return c.json({
      error: 'Validation Error',
      message: 'Request data validation failed.',
      requestId,
      type: 'VALIDATION_ERROR',
      timestamp: new Date().toISOString(),
      responseTime
    }, 400)
  }

  // Generic server error with enhanced info
  return c.json({
    error: 'Internal Server Error',
    message: 'An unexpected error occurred. Please try again.',
    requestId,
    type: 'INTERNAL_ERROR',
    timestamp: new Date().toISOString(),
    responseTime,
    ...(c.env.ENVIRONMENT === 'development' && {
      debug: {
        message: err.message,
        stack: err.stack?.substring(0, 200)
      }
    })
  }, 500)
})

// Enhanced 404 handler
app.notFound((c) => {
  const startTime = c.get('startTime') || Date.now()

  return c.json({
    error: 'Not Found',
    message: 'The requested endpoint does not exist',
    path: c.req.path,
    method: c.req.method,
    suggestions: [
      'Check the API documentation at /graphql',
      'Try the demo UI at /ui/demo',
      'View available endpoints in GraphiQL'
    ],
    requestId: c.get('requestId'),
    timestamp: new Date().toISOString(),
    responseTime: Date.now() - startTime
  }, 404)
})

// üß™ NEW: Testing Client Export (for development)
export const client = testClient(app)
export type AppType = typeof app

export default app
