#!/usr/bin/env node

/**
 * LunarCrush Universal - Direct Package Type Generation
 * Generates TypeScript types directly in each package from GraphQL schema
 */

const fs = require('fs');
const path = require('path');

console.log('ğŸ”„ Generating types directly in packages...');

const schemaPath = 'schema/schema.graphql';

// Read GraphQL schema
if (!fs.existsSync(schemaPath)) {
    console.error('âŒ Schema file not found:', schemaPath);
    process.exit(1);
}

const schemaContent = fs.readFileSync(schemaPath, 'utf8');
console.log(`ğŸ“Š Schema content: ${schemaContent.length} characters`);

// Helper function to parse GraphQL schema into TypeScript
function generateTypeScriptTypes(schemaContent) {
    const lines = schemaContent.split('\n').map(line => line.trim());
    let types = [];
    let enums = [];

    // Simple parser - extract type and enum definitions
    let currentType = null;
    let inType = false;

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];

        // Skip comments and empty lines
        if (line.startsWith('#') || line === '') continue;

        // Parse enum definitions
        if (line.startsWith('enum ')) {
            const enumName = line.replace('enum ', '').replace(' {', '');
            let enumValues = [];
            i++; // Move to first enum value

            while (i < lines.length && !lines[i].includes('}')) {
                const value = lines[i].trim();
                if (value && !value.startsWith('#')) {
                    enumValues.push(value);
                }
                i++;
            }

            enums.push({
                name: enumName,
                values: enumValues
            });
        }

        // Parse type definitions (skip Query, Mutation, Subscription)
        if (line.startsWith('type ') && !line.includes('Query') && !line.includes('Mutation') && !line.includes('Subscription')) {
            const typeName = line.replace('type ', '').replace(' {', '');
            let fields = [];
            i++; // Move to first field

            while (i < lines.length && !lines[i].includes('}')) {
                const field = lines[i].trim();
                if (field && !field.startsWith('#')) {
                    // Parse field: name: Type
                    const [fieldName, fieldType] = field.split(':').map(s => s.trim());
                    if (fieldName && fieldType) {
                        fields.push({
                            name: fieldName,
                            type: fieldType.replace(/[!\[\]]/g, '') // Remove GraphQL modifiers
                        });
                    }
                }
                i++;
            }

            types.push({
                name: typeName,
                fields: fields
            });
        }
    }

    return { types, enums };
}

// Generate TypeScript code
function generateTypeScriptCode(types, enums) {
    let code = `// ===================================================================
// ğŸš¨ AUTO-GENERATED FILE - DO NOT EDIT MANUALLY! ğŸš¨
// ===================================================================
// This file is automatically generated from schema/schema.graphql
// To make changes:
// 1. Edit schema/schema.graphql
// 2. Run: npm run codegen
// ===================================================================

/**
 * LunarCrush API Types - Auto-Generated
 * Source: schema/schema.graphql
 * Generated: ${new Date().toISOString()}
 */

// Scalar types
export type Date = Date;
export type JSON = any;

`;

    // Generate enums
    enums.forEach(enumDef => {
        code += `export enum ${enumDef.name} {\n`;
        enumDef.values.forEach(value => {
            code += `  ${value} = '${value}',\n`;
        });
        code += `}\n\n`;
    });

    // Generate interfaces
    types.forEach(typeDef => {
        code += `export interface ${typeDef.name} {\n`;
        typeDef.fields.forEach(field => {
            let tsType = field.type;
            // Convert GraphQL types to TypeScript
            switch (field.type) {
                case 'String': tsType = 'string | null'; break;
                case 'Int': tsType = 'number | null'; break;
                case 'Float': tsType = 'number | null'; break;
                case 'Boolean': tsType = 'boolean | null'; break;
                case 'Date': tsType = 'Date | null'; break;
                case 'JSON': tsType = 'any | null'; break;
                default:
                    if (field.type.includes('[')) {
                        tsType = field.type.replace(/\[(\w+)\]/, '$1[] | null');
                    } else {
                        tsType = `${field.type} | null`;
                    }
            }
            code += `  ${field.name}?: ${tsType};\n`;
        });
        code += `}\n\n`;
    });

    return code;
}

// Parse schema
const { types, enums } = generateTypeScriptTypes(schemaContent);
const typeScriptCode = generateTypeScriptCode(types, enums);

// Packages that need types
const packages = [
    'packages/backend-yoga',
    'packages/sdk',
    'packages/cli'
];

// Generate types for each package
packages.forEach(packagePath => {
    if (fs.existsSync(packagePath)) {
        const outputPath = path.join(packagePath, 'src/generated/types.ts');
        const outputDir = path.dirname(outputPath);

        // Create generated directory
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }

        // Write types file
        fs.writeFileSync(outputPath, typeScriptCode);
        console.log(`âœ… Generated ${outputPath}`);
    } else {
        console.log(`âš ï¸  Package not found: ${packagePath}`);
    }
});

console.log(`âœ… Generated types for ${packages.length} packages`);
console.log(`ğŸ“Š Generated: ${types.length} interfaces, ${enums.length} enums`);
console.log('ğŸ¯ Ready for package-specific usage!');
