#!/usr/bin/env node

/**
 * LunarCrush Universal - Enhanced Package Type Generation
 * Replaces shared-types with direct package codegen
 *
 * Usage: npm run codegen:all
 */

const fs = require('fs');
const path = require('path');

console.log('🔄 LunarCrush Universal - Generating all package types...');

const schemaPath = 'schema/schema.graphql';

// Package configurations
const packages = [
    {
        name: 'backend-yoga',
        path: 'packages/backend-yoga',
        generateSchema: true,  // Also generates schema.ts for GraphQL Yoga
        generateTypes: true    // Generates types.ts for TypeScript
    },
    {
        name: 'sdk',
        path: 'packages/sdk',
        generateSchema: false,
        generateTypes: true
    },
    {
        name: 'cli',
        path: 'packages/cli',
        generateSchema: false,
        generateTypes: true
    }
];

// Read GraphQL schema
if (!fs.existsSync(schemaPath)) {
    console.error('❌ Schema file not found:', schemaPath);
    process.exit(1);
}

const schemaContent = fs.readFileSync(schemaPath, 'utf8');
console.log(`📊 Schema: ${schemaContent.length} chars, ${schemaContent.split('\n').length} lines`);

// Generate schema file for GraphQL Yoga (backend-yoga only)
function generateSchemaFile(schemaContent) {
    return `// ===================================================================
// 🚨 AUTO-GENERATED FILE - DO NOT EDIT MANUALLY! 🚨
// ===================================================================
// This file is automatically generated from schema/schema.graphql
// To make changes:
// 1. Edit schema/schema.graphql
// 2. Run: npm run codegen:all
// ===================================================================

/**
 * LunarCrush GraphQL Schema - Auto-Generated
 * Source: schema/schema.graphql (${schemaContent.split('\n').length} lines)
 * Generated: ${new Date().toISOString()}
 */

export const typeDefs = \`${schemaContent.replace(/`/g, '\\`')}\`;

// Re-export for compatibility
export default typeDefs;
`;
}

// Enhanced TypeScript type generation
function generateTypeScriptTypes(schemaContent) {
    const lines = schemaContent.split('\n').map(line => line.trim());
    let types = [];
    let enums = [];

    // Parse enums
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];

        if (line.startsWith('enum ')) {
            const enumName = line.replace('enum ', '').replace(' {', '');
            let enumValues = [];
            i++; // Move to first enum value

            while (i < lines.length && !lines[i].includes('}')) {
                const value = lines[i].trim();
                if (value && !value.startsWith('#') && value !== '') {
                    enumValues.push(value);
                }
                i++;
            }

            if (enumValues.length > 0) {
                enums.push({
                    name: enumName,
                    values: enumValues
                });
            }
        }
    }

    // Parse types (skip Query, Mutation, Subscription)
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];

        if (line.startsWith('type ') &&
            !line.includes('Query') &&
            !line.includes('Mutation') &&
            !line.includes('Subscription')) {

            const typeName = line.replace('type ', '').replace(' {', '');
            let fields = [];
            i++; // Move to first field

            while (i < lines.length && !lines[i].includes('}')) {
                const field = lines[i].trim();
                if (field && !field.startsWith('#') && field.includes(':')) {
                    // Parse field: name: Type
                    const colonIndex = field.indexOf(':');
                    const fieldName = field.substring(0, colonIndex).trim();
                    const fieldType = field.substring(colonIndex + 1).trim();

                    if (fieldName && fieldType) {
                        fields.push({
                            name: fieldName,
                            type: fieldType
                        });
                    }
                }
                i++;
            }

            if (fields.length > 0) {
                types.push({
                    name: typeName,
                    fields: fields
                });
            }
        }
    }

    return { types, enums };
}

// Generate TypeScript code
function generateTypeScriptCode(types, enums, packageName) {
    let code = `// ===================================================================
// 🚨 AUTO-GENERATED FILE - DO NOT EDIT MANUALLY! 🚨
// ===================================================================
// This file is automatically generated from schema/schema.graphql
// To make changes:
// 1. Edit schema/schema.graphql
// 2. Run: npm run codegen:all
// ===================================================================

/**
 * LunarCrush API Types - Auto-Generated for ${packageName}
 * Source: schema/schema.graphql
 * Generated: ${new Date().toISOString()}
 *
 * This replaces the old @lunarcrush/shared-types package
 * Each package now generates its own types directly from the schema
 */

// Scalar types
export type Date = Date;
export type JSON = any;

`;

    // Generate enums
    if (enums.length > 0) {
        code += `// ===== ENUMS =====\n\n`;
        enums.forEach(enumDef => {
            code += `export enum ${enumDef.name} {\n`;
            enumDef.values.forEach(value => {
                code += `  ${value} = '${value}',\n`;
            });
            code += `}\n\n`;
        });
    }

    // Generate interfaces
    if (types.length > 0) {
        code += `// ===== INTERFACES =====\n\n`;
        types.forEach(typeDef => {
            code += `export interface ${typeDef.name} {\n`;
            typeDef.fields.forEach(field => {
                let tsType = convertGraphQLTypeToTypeScript(field.type);
                code += `  ${field.name}?: ${tsType};\n`;
            });
            code += `}\n\n`;
        });
    }

    // Add helper types
    code += `// ===== HELPER TYPES =====\n\n`;
    code += `export interface LunarCrushAPIResponse<T> {\n`;
    code += `  data?: T;\n`;
    code += `  status?: string;\n`;
    code += `  config?: any;\n`;
    code += `}\n\n`;

    return code;
}

// Convert GraphQL types to TypeScript
function convertGraphQLTypeToTypeScript(graphqlType) {
    // Remove GraphQL modifiers
    let cleanType = graphqlType.replace(/[!\[\]]/g, '').trim();

    // Convert GraphQL scalar types to TypeScript
    switch (cleanType) {
        case 'String': return 'string | null';
        case 'Int': return 'number | null';
        case 'Float': return 'number | null';
        case 'Boolean': return 'boolean | null';
        case 'Date': return 'Date | null';
        case 'JSON': return 'any | null';
        default:
            // Handle arrays
            if (graphqlType.includes('[')) {
                return `${cleanType}[] | null`;
            }
            return `${cleanType} | null`;
    }
}

// Main generation logic
console.log('🔍 Parsing GraphQL schema...');
const { types, enums } = generateTypeScriptTypes(schemaContent);
console.log(`📊 Parsed: ${types.length} types, ${enums.length} enums`);

let generatedCount = 0;
let errorCount = 0;

// Generate for each package
packages.forEach(pkg => {
    console.log(`\n📦 Processing package: ${pkg.name}`);

    if (!fs.existsSync(pkg.path)) {
        console.log(`⚠️  Package directory not found: ${pkg.path}`);
        return;
    }

    // Create generated directory
    const generatedDir = path.join(pkg.path, 'src/generated');
    if (!fs.existsSync(generatedDir)) {
        fs.mkdirSync(generatedDir, { recursive: true });
        console.log(`📁 Created directory: ${generatedDir}`);
    }

    try {
        // Generate schema.ts for GraphQL Yoga (backend-yoga only)
        if (pkg.generateSchema) {
            const schemaPath = path.join(pkg.path, 'src/schema.ts');
            const schemaCode = generateSchemaFile(schemaContent);
            fs.writeFileSync(schemaPath, schemaCode);
            console.log(`✅ Generated schema: ${schemaPath}`);
            generatedCount++;
        }

        // Generate types.ts for all packages
        if (pkg.generateTypes) {
            const typesPath = path.join(generatedDir, 'types.ts');
            const typesCode = generateTypeScriptCode(types, enums, pkg.name);
            fs.writeFileSync(typesPath, typesCode);
            console.log(`✅ Generated types: ${typesPath}`);
            generatedCount++;
        }

    } catch (error) {
        console.error(`❌ Error generating for ${pkg.name}:`, error.message);
        errorCount++;
    }
});

// Summary
console.log('\n' + '='.repeat(60));
console.log(`🎉 Code generation complete!`);
console.log(`✅ Generated: ${generatedCount} files`);
console.log(`❌ Errors: ${errorCount}`);
console.log(`📊 Types: ${types.length} interfaces, ${enums.length} enums`);
console.log(`🎯 Architecture: Direct package codegen (no shared-types)`);
console.log('='.repeat(60));

if (errorCount === 0) {
    console.log('\n🚀 All packages ready with auto-generated types!');
} else {
    console.log('\n⚠️  Some packages had errors. Check output above.');
    process.exit(1);
}
